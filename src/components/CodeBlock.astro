---
import CopyCodeBlockButton from '@components/CopyCodeBlockButton'
import DevIcon from '@components/DevIcon.astro'
import type { DevIconName } from '@components/DevIcon.astro'
import { useTranslate } from '@utils/i18n'
import type { Lang } from 'shiki'
import type { HTMLAttributes } from 'astro/types'
import '@assets/css/twoslash.css'
import IconButton from './IconButton'
import { isDevIcon } from '@utils/devicons'
import _ from 'lodash'
import shiki from 'shiki'
import {
  renderCodeToHTML,
  runTwoSlash,
  createShikiHighlighter,
} from 'shiki-twoslash'
import { fromHtml } from 'hast-util-from-html'
import { toHtml } from 'hast-util-to-html'
import { select } from 'hast-util-select'
import { h } from 'hastscript'
import { parseHighlightString } from '@utils/code-block'
import type { Nodes } from 'node_modules/hast-util-select/lib'

const t = useTranslate(Astro)

export type CodeBlockProps = {
  title: string
  lang: Lang
  twoslash: boolean
  code: string
  highlight: string
}

type Props = HTMLAttributes<'pre'> & CodeBlockProps

const {
  title = '',
  lang = 'plaintext',
  highlight = '',
  code = '',
  twoslash = false,
  ...rest
} = Astro.props

const THEME = 'one-dark-pro'

const shikiTheme = await shiki.loadTheme(`themes/${THEME}.json`)

const highlighter = await createShikiHighlighter({
  theme: THEME,
})

let codeToCopy = code
let codeBlockHtml = null
let typescriptPlaygroundURL = null

if (twoslash) {
  const twoslashResults = runTwoSlash(code, lang)

  codeToCopy = twoslashResults.code
  typescriptPlaygroundURL = twoslashResults.playgroundURL

  const twoslashHtml = renderCodeToHTML(
    twoslashResults.code,
    twoslashResults.extension,
    { title, highlight, twoslash: true },
    {
      themeName: THEME,
    },
    highlighter,
    twoslashResults
  )

  const twoslashHast = fromHtml(twoslashHtml, { fragment: true })

  // The code blocks generated by twoslash look like this:
  //
  // <pre class='shiki lsp twoslash [theme-name]'>
  //   <div class='language-id'>[lang-id]</div>
  //     <div class='code-container'>
  //       <code>[the code as a series of spans]</code>
  //       <a href='playground...'>Try</a> (optional)
  //     </div>
  //   </div>
  // </pre>
  //
  // Here, we try to get only the children of the `code` tag.
  const codeElement = select('code', twoslashHast as Nodes)

  if (codeElement) {
    codeBlockHtml = toHtml(codeElement)
  }
} else {
  const lines = highlighter.codeToThemedTokens(code, lang)

  const highlightedLines = parseHighlightString(highlight)

  const syntaxHighlightedCode = lines.map((line, index) => {
    const isLineHighlighted = highlightedLines.includes(index + 1)
    const isEmptyLine = line.length === 0

    return h(
      'span',
      {
        className: isLineHighlighted
          ? `line ${isLineHighlighted && 'highlight'}`
          : 'line',
      },
      isEmptyLine
        ? h('span', {}, ' ')
        : line.map((token) => {
            return h(
              'span',
              token.color ? { style: `color: ${token.color}` } : {},
              token.content
            )
          })
    )
  })

  codeBlockHtml = toHtml(h('code', {}, syntaxHighlightedCode) as Nodes)
}

function getDevIconNameByShikiLang(lang: Lang) {
  const shikiLangToDevIconName: Partial<Record<Lang, DevIconName>> = {
    jsx: 'Javascript',
    tsx: 'Typescript',
    js: 'Javascript',
    ts: 'Typescript',
    shell: 'Bash',
  }

  if (lang in shikiLangToDevIconName) {
    return (
      shikiLangToDevIconName[lang as keyof typeof shikiLangToDevIconName] ??
      null
    )
  }

  return null
}

function getShikiLangName(lang: Lang) {
  const shikiLangToName: Partial<Record<Lang, string>> = {
    jsx: 'JavaScript',
    tsx: 'TypeScript',
    javascript: 'JavaScript',
    js: 'JavaScript',
    ts: 'TypeScript',
    typescript: 'TypeScript',
    shell: 'Bash',
    html: 'HTML',
    css: 'CSS',
    mdx: 'MDX',
    python: 'Python',
  }

  if (lang in shikiLangToName) {
    return shikiLangToName[lang as keyof typeof shikiLangToName] ?? null
  }

  return null
}

const langName = getShikiLangName(Astro.props.lang) || Astro.props.lang

const langComponentName = _.upperFirst(Astro.props.lang)

const devIconName = isDevIcon(langComponentName)
  ? langComponentName
  : lang !== 'plaintext' && getDevIconNameByShikiLang(lang)
---

<style
  is:global
  define:vars={{ 'code-bg': shikiTheme.bg, 'code-fg': shikiTheme.fg }}
></style>

<div data-codeblock class='last:mb-0 max-w-2xl'>
  <div
    data-codeblock-header
    class:list={[
      'dark',
      'flex',
      'items-center',
      'gap-2',
      'rounded-t',
      'py-1',
      'bg-[var(--code-bg)]',
      'text-[var(--code-fg)]',
      'border-b',
      'border-divider',
    ]}
  >
    <div
      class:list={['flex', 'pl-horizontal-padding', 'items-center', 'gap-2']}
    >
      {devIconName && <DevIcon name={devIconName} />}

      <div class:list={['rtl', 'truncate', 'text-lg']}>
        {
          title ? (
            <bdi>{title}</bdi>
          ) : langName === 'plaintext' || langName === '' ? (
            t.NoName()
          ) : (
            langName
          )
        }
      </div>
    </div>

    <div class='ml-auto flex flex-row gap-2 [&_svg]:h-6 [&_svg]:w-6 pr-2'>
      {
        typescriptPlaygroundURL && (
          <IconButton
            variant='rounded'
            href={typescriptPlaygroundURL}
            target='_blank'
            className='[&_svg_*]:fill-[var(--code-fg)]'
          >
            <DevIcon name='Typescript' />
          </IconButton>
        )
      }

      <CopyCodeBlockButton
        client:load
        successText={t.Copied() + '!'}
        errorText={t.FailedToCopy()}
        code={codeToCopy}
      />
    </div>
  </div>

  <pre
    class:list={[
      'shiki',
      twoslash && 'twoslash',
      'shadow-sm',
      'shadow-shadow',
      'rounded-b',
      'overflow-x-auto',
      'bg-[var(--code-bg)]',
      'text-[var(--code-fg)]',
      '[color-scheme:dark]',
      '[&_code]:py-4',
      '[&_code]:grid',
      '[&_code>.line]:px-horizontal-padding',
      '[&_code>.line]:border-l-[2px]',
      '[&_code>.line]:border-[var(--code-bg)]',
      '[&_code>.line.highlight]:bg-[#272115]',
      '[&_code>.line.highlight]:border-[#624710]',
      '[&_.error]:text-sm',
      '[&_.error]:px-8',
      '[&_.error]:py-1',
      '[&_.popover]:my-2',
      '[&_.popover]:rounded-sm',
      '[&_.popover]:bg-gray-700',
      '[&_.popover]:text-white',
      '[&_.arrow]:bg-gray-700',
      '[&_.arrow]:border-gray-700',
      Astro.props.class,
    ]}
    {...rest}><Fragment set:html={codeBlockHtml} /></pre>
</div>

<script>
  import { computePosition, offset, flip } from '@floating-ui/dom'

  for (const lspElement of document.querySelectorAll<HTMLElement>(
    '[data-codeblock] pre.twoslash data-lsp'
  )) {
    lspElement.addEventListener('mouseover', async (e) => {
      if (!e.target) {
        return
      }

      const tooltip = document.createElement('div')
      const reference = e.target as HTMLElement

      tooltip.setAttribute('role', 'tooltip')

      const tooltipId = 'twoslash-lsp-tooltip'
      tooltip.setAttribute('id', tooltipId)
      reference.setAttribute('aria-describedby', tooltipId)

      const { x, y } = await computePosition(reference, tooltip, {
        placement: 'bottom-start',
        middleware: [offset(8), flip()],
      })

      Object.assign(tooltip.style, {
        left: `${x}px`,
        top: `${y}px`,
      })

      const lspText = reference.getAttribute('lsp')
      tooltip.textContent = lspText
      tooltip.classList.add(
        'font-mono',
        'absolute',
        'bg-gray-700',
        'text-white',
        'text-left',
        'p-2',
        'text-sm',
        'whitespace-pre-wrap'
      )

      document.body.append(tooltip)

      reference.addEventListener(
        'mouseout',
        () => {
          tooltip.remove()
          reference.removeAttribute('aria-describedby')
        },
        {
          once: true,
        }
      )
    })
  }
</script>
