---
import CopyCodeBlockButton from '@components/CopyCodeBlockButton'
import DevIcon, { DevIcons } from '@components/DevIcon.astro'
import { useTranslate } from '@utils/i18n/useTranslate'
import type { ShikiTransformer, ThemeRegistration } from 'shiki'
// Using `string` for ShikiLang as a general type since specific 'Lang' import is problematic
type ShikiLang = string
import type { HTMLAttributes } from 'astro/types'
import '@assets/css/twoslash.css' // This has been updated with style-rich.css content
import IconButton from './IconButton'
import _ from 'lodash'
import { codeToHtml } from 'shiki'
import { transformerTwoslash, rendererRich } from '@shikijs/twoslash'
import { bundledThemes } from 'shiki/themes'
import { parseHighlightString } from '@utils/code-block'
import type { Locale } from '@utils/i18n/locales'

export type CodeBlockProps = {
  title: string
  lang: ShikiLang
  twoslash: boolean
  code: string
  highlight: string
  locale: Locale
}

type Props = HTMLAttributes<'pre'> & CodeBlockProps

const {
  title = '',
  lang = 'plaintext',
  highlight = '',
  code = '',
  twoslash = false,
  locale,
  ...rest
} = Astro.props

const t = useTranslate(locale)

const THEME_NAME = 'one-dark-pro'
// ThemeRegistration can be a string, or an IThemeRegistration (which has bg, fg etc.)
const shikiThemeObject = bundledThemes[THEME_NAME] as
  | ThemeRegistration
  | undefined

let themeBg = '#282c34' // Default background from one-dark-pro
let themeFg = '#abb2bf' // Default foreground from one-dark-pro

if (
  shikiThemeObject &&
  typeof shikiThemeObject === 'object' &&
  'bg' in shikiThemeObject &&
  'fg' in shikiThemeObject
) {
  // It's an IThemeRegistration like object
  themeBg = shikiThemeObject.bg || themeBg
  themeFg = shikiThemeObject.fg || themeFg
} else if (!shikiThemeObject) {
  console.warn(`Shiki theme "${THEME_NAME}" not found. Using fallback styling.`)
} else if (typeof shikiThemeObject === 'string') {
  // If it's just a string (theme name), we can't get bg/fg directly here.
  // Shiki's codeToHtml will load it, but we won't have bg/fg for CSS vars *before* rendering.
  // This is generally okay as the <pre> tag itself will get Shiki's styles.
  // The define:vars is a progressive enhancement.
  console.warn(
    `Shiki theme "${THEME_NAME}" is a string, not an object. CSS variables for bg/fg might not be optimally set from here.`
  )
}

let codeToCopy = code
let codeBlockHtml = ''
let typescriptPlaygroundURL: string | null = null

const transformers: ShikiTransformer[] = []

// Custom transformer for line highlighting based on the `highlight` prop
if (highlight) {
  const highlightedLines = parseHighlightString(highlight)
  if (highlightedLines.length > 0) {
    transformers.push({
      name: 'custom-line-highlighter',
      line(hastNode, line) {
        if (highlightedLines.includes(line)) {
          this.addClassToHast(hastNode, 'highlight')
        }
        return hastNode
      },
    })
  }
}

if (twoslash) {
  transformers.push(
    transformerTwoslash({
      renderer: rendererRich(), // Explicitly using rich renderer, which is default
      // explicitTrigger: true, // if we wanted to require 'twoslash' in meta
    })
  )
}

// This transformer will run after twoslash and other transformers
// to attempt to extract the playground URL if set by transformerTwoslash.
const playgroundUrlExtractor: ShikiTransformer = {
  name: 'playground-url-extractor',
  pre(hastNode) { // Changed `node` to `hastNode` for clarity
    // The pre hook gets the <pre> element
    // console.log('Playground extractor pre node:', JSON.stringify(hastNode, null, 2)); // For debugging
    if (hastNode.properties?.['data-playground-url']) {
      typescriptPlaygroundURL = String(hastNode.properties['data-playground-url']);
      // console.log('Found playground URL:', typescriptPlaygroundURL); // For debugging
    }
    // Twoslash might also modify the code for copying (e.g. removing types for JS output)
    // `this.source` in a transformer *might* give the final source code.
    // For now, `codeToCopy` remains original code, which is usually fine.
    return hastNode; // Transformers should return the node
  },
}
transformers.push(playgroundUrlExtractor)

try {
  codeBlockHtml = await codeToHtml(code, {
    lang: lang as ShikiLang,
    theme:
      shikiThemeObject && typeof shikiThemeObject !== 'string'
        ? shikiThemeObject
        : THEME_NAME,
    transformers,
  })
  if (Astro.url.pathname.includes('deriving-types-from-data-typescript') && twoslash) {
    console.log('CodeBlock.astro - Twoslash HTML for deriving-types-from-data-typescript:');
    console.log(codeBlockHtml);
  }
} catch (error) {
  console.error('Error rendering code block with Shiki:', error)
  codeBlockHtml = `<pre><code>Error rendering code: ${_.escape(
    code
  )}</code></pre>` // Fallback
}

function getDevIconName(lang: ShikiLang): keyof typeof DevIcons | null {
  if (lang in DevIcons) {
    return lang as keyof typeof DevIcons
  }

  const shikiLangToDevIconName: Partial<
    Record<ShikiLang, keyof typeof DevIcons>
  > = {
    jsx: 'javascript',
    tsx: 'typescript',
    js: 'javascript',
    ts: 'typescript',
    shell: 'bash',
  }

  if (lang in shikiLangToDevIconName) {
    return shikiLangToDevIconName[lang] ?? null
  }

  return null
}

function getShikiLangName(lang: ShikiLang) {
  const shikiLangToName: Partial<Record<ShikiLang, string>> = {
    jsx: 'JavaScript',
    tsx: 'TypeScript',
    javascript: 'JavaScript',
    js: 'JavaScript',
    ts: 'TypeScript',
    typescript: 'TypeScript',
    shell: 'Bash',
    html: 'HTML',
    css: 'CSS',
    mdx: 'MDX',
    python: 'Python',
  }

  if (lang in shikiLangToName) {
    return shikiLangToName[lang] ?? null
  }

  return null
}

const langName =
  getShikiLangName(Astro.props.lang as ShikiLang) || Astro.props.lang

const devIconName = getDevIconName(Astro.props.lang as ShikiLang)
---

<style is:global define:vars={{ 'code-bg': themeBg, 'code-fg': themeFg }}
></style>

<div data-codeblock class='last:mb-0 max-w-2xl'>
  <div
    data-codeblock-header
    class:list={[
      'dark',
      'flex',
      'items-center',
      'gap-2',
      'rounded-t',
      'py-1',
      'bg-[var(--code-bg)]',
      'text-[var(--code-fg)]',
      'border-b',
      'border-divider',
    ]}
  >
    <div
      class:list={['flex', 'pl-horizontal-padding', 'items-center', 'gap-2']}
    >
      {devIconName !== null && <DevIcon size='1em' name={devIconName} />}

      <div class:list={['rtl', 'truncate', 'text-lg']}>
        {
          title ? (
            <bdi>{title}</bdi>
          ) : langName === 'plaintext' || langName === '' ? (
            t['NoName']
          ) : (
            langName
          )
        }
      </div>
    </div>

    <div class='ml-auto flex flex-row gap-2 pr-2'>
      {
        typescriptPlaygroundURL && (
          <IconButton
            variant='rounded'
            href={typescriptPlaygroundURL}
            target='_blank'
            className='[&_svg_*]:fill-[var(--code-fg)]'
          >
            <DevIcon size='24px' name='typescript' />
          </IconButton>
        )
      }

      <CopyCodeBlockButton
        client:load
        successText={t['Copied'] + '!'}
        errorText={t['FailedToCopy']}
        code={codeToCopy}
      />
    </div>
  </div>

  <pre
    class:list={[
      'shiki',
      twoslash && 'twoslash',
      'shadow-sm',
      'shadow-shadow',
      'rounded-b',
      'overflow-x-auto',
      'bg-[var(--code-bg)]',
      'text-[var(--code-fg)]',
      '[color-scheme:dark]',
      '[&_code]:py-4',
      '[&_code]:grid',
      '[&_code>.line]:px-horizontal-padding',
      '[&_code>.line]:border-l-[2px]',
      '[&_code>.line]:border-[var(--code-bg)]',
      '[&_code>.line.highlight]:bg-[#272115]',
      '[&_code>.line.highlight]:border-[#624710]',
      '[&_.error]:text-sm',
      '[&_.error]:px-8',
      '[&_.error]:py-1',
      '[&_.popover]:my-2',
      '[&_.popover]:rounded-sm',
      '[&_.popover]:bg-gray-700',
      '[&_.popover]:text-white',
      '[&_.arrow]:bg-gray-700',
      '[&_.arrow]:border-gray-700',
      Astro.props.class,
    ]}
    {...rest}><Fragment set:html={codeBlockHtml} /></pre>
</div>

<script>
  import { computePosition, offset, flip } from '@floating-ui/dom'

  for (const lspElement of document.querySelectorAll<HTMLElement>(
    '[data-codeblock] pre.twoslash data-lsp'
  )) {
    lspElement.addEventListener('mouseover', async (e) => {
      if (!e.target) {
        return
      }

      const tooltip = document.createElement('div')
      const reference = e.target as HTMLElement

      tooltip.setAttribute('role', 'tooltip')

      const tooltipId = 'twoslash-lsp-tooltip'
      tooltip.setAttribute('id', tooltipId)
      reference.setAttribute('aria-describedby', tooltipId)

      const { x, y } = await computePosition(reference, tooltip, {
        placement: 'bottom-start',
        middleware: [offset(8), flip()],
      })

      Object.assign(tooltip.style, {
        left: `${x}px`,
        top: `${y}px`,
      })

      const lspText = reference.getAttribute('lsp')
      tooltip.textContent = lspText
      tooltip.classList.add(
        'font-mono',
        'absolute',
        'bg-gray-700',
        'text-white',
        'text-left',
        'p-2',
        'text-sm',
        'whitespace-pre-wrap'
      )

      document.body.append(tooltip)

      reference.addEventListener(
        'mouseout',
        () => {
          tooltip.remove()
          reference.removeAttribute('aria-describedby')
        },
        {
          once: true,
        }
      )
    })
  }
</script>
